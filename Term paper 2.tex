% XeLaTeX can use any Mac OS X font. See the setromanfont command below.
% Input to XeLaTeX is full Unicode, so Unicode characters can be typed directly into the source.

% The next lines tell TeXShop to typeset with xelatex, and to open and save the source with Unicode encoding.

%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\documentclass[12pt]{article}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\newcommand\tab[1][-1em]{\hspace*{#1}}
\newcommand\tb[1][10pt]{\hspace*{#1}}

\def\mathbi#1{\textbf{\em #1}}
\usepackage{listings}

\usepackage{scrextend}

% Will Robertson's fontspec.sty can be used to simplify font choices.
% To experiment, open /Applications/Font Book to examine the fonts provided on Mac OS X,
% and change "Hoefler Text" to any of these choices.

\usepackage{fontspec,xltxtra,xunicode}
\usepackage{amsthm}
\newtheorem*{remark}{Remark}
\newtheorem{definition}{Definition}[section]
\newtheorem{idea}{Idea}[section]


\title{Turing Machine}
\author{Artemii Yanushevskyi}
\date{}

\begin{document}

\maketitle

\begin{addmargin}[3em]{3em}
\abstract{The second half of twentieth century is characterized by a rapid bloom of technology. It was influenced primarily by mathematicians who tried to relate non-mathematical objects, such as mechanisms, with purely mathematical, like mathematical logic. Allan Turing was asked, what is a `mechanical' process, he replied, it is the `process' which can be done by a machine. It is a reasonable answer, but how would we define a `machine' then? Turing decided to elaborate such general notion of a machine. This contributed to the appearance of machine that we call in his name: Turing machine.}
\end{addmargin}

\section{Intuitive definition}
\textbf{\large L}ets assume that we have a creature that can observe a single place on infinite tape. Every place has either 1 or 0 on itself. This creature can move a tape to left or right, and rewrite a digit in front of it. Additionally, the creature has a number of states, which include terminal state `$\mathrm{q}0$'. This creature acts upon what state it currently holds and what it is seeing on a tape at the moment. 

We will call that entire system \emph{Turing machine}.

The input is a tape. Despite the tape is infinite, it should have just finite number of 1.
We can represent each vector $x\in\mathbb{N}^k$ as a string of $k$ blocks with $(x_i+1)$ 1. Those blocks are separated with 0. 

 \vspace{5mm}
\begin{addmargin}[3em]{3em}
\tab
\textsc{Example.} The vector $x=(3,\ 2,\ 1,\ 0)\in\mathbb{N}^4$ is represented on a tape

{\large $$\dots 0001111011101101000\dots$$}

\end{addmargin}

The machine performs basic operations: check a number on a tape, move left or right, and change its state. The rules which guide the machine is presented in a list of commands, which is called a Turing code. What the creature will do next depends on two factors: what it sees on a tape at the moment and what state it has.
 
 \vspace{5mm}
\begin{addmargin}[3em]{3em}
\tab
\textsc{Example.} Now we will make a typical single command of the machine. After, we will write a command that corresponds to it. In case creature
\begin{enumerate}
\item has the state $\mathrm{q}3$ and \item sees 0 on a place,
\end{enumerate}
the creature should: 
\begin{enumerate}
\item change a number on a place from 0 to 1 \item move a strip left in order to face with a place to the right side \item change a state to $\mathrm{q}3$. 
\end{enumerate}


The command that defines this process is the following:

{\large $$(\mathrm{q}2, 1)\ ->\ (\mathrm{q}2, 1, \mathrm{R})$$}
\end{addmargin}
Usually the starting position is a first 1. The starting state is $\mathrm{q}1$, we will call it terminal state.
% a command
Below is an example of code, that adds $a$ and $b$. The input vector $(a,\ b)\in\mathbb{N}^2$.

\begin{lstlisting}
(q1, 1) -> (q1, 1, R)
(q1, 0) -> (q2, 1, R)
(q2, 1) -> (q2, 1, R)
(q2, 0) -> (q3, 0, L)
(q3, 0) -> (q0, 0, L)
(q3, 1) -> (q4, 0, L)
(q4, 1) -> (q5, 0, L)
(q5, 1) -> (q5, 1, L)
(q5, 0) -> (q0, 0, S)
\end{lstlisting}

The result line will consist of $(a+b+1)$ 1 in a single row, which represents $a+b$.
\begin{remark} When machine acquires state $\mathrm{q}0$, it stops. After machine stops we can read the output row.
\end{remark}

\section{Mathematical definition}
\textbf{\large T}he intuitive definition given above boils down to a specific set of functions. 
\begin{definition}
Turing machine is a map
$$ M:\{\mathrm{q}0,\ \dots\ ,\ \mathrm{q}n\} \times \{ 1,\ 0\} \rightarrow \{\mathrm{q}0,\ \dots\ ,\ \mathrm{q}n\} \times \{ 1,\ 0\} \times \{L,\ S,\ R\}$$
where $\{\mathrm{q}0,\ \dots\ ,\ \mathrm{q}n\}$ -- is a set of states, 0 and 1 is alphabet of machine, and each element is a command.
\end{definition}

We say that function can be computed by a Turing machine if there is a Turing machine which has the same input-output set as the function does. It has been demonstrated that any algorithm (in intuitive sense) can be presented as some Turing machine.

\section{A model of Turing machine}
\textbf{\large I}t is unbelievable that all algorithms and function, regardless of their complexity, can be represented in such easy and intuitive `mechanical' model. Turing machine is regarded as an ultimate computing machine.

This mechanical process of computing a function attracted my interest and I built a real model of an abstract Turing machine, the only difference is that the size of a tape is restricted by a computer RAM memory. 8 GB of RAM memory can contain $8e+9$ long tape. 

The application consists of a few different modules. The most important part is \verb|TuringCore.py| where all actions by machine are being performed. Other modules deal with design, input data processing, visualization and etc. Turing created his machine hypothetically, but now we can operate with its real analog.

\section{How to work with application}
\textbf{\large T}he program requires Python 3.5. To run the app open \verb|TuringMachie.py| in IDLE and click `Tun Module' in top menu. The navigation window wit pop up. The top element is a navigation bar, it has 3 indicators. This bar is made to assist a user through the process. A first indicator lights up when a user selects a Turing code. Second, indicates that Turing machine has a compiled version of code. Later, it will be executed on input numbers. The last indicator turns on after we choose input values.

The next section is a where we gather all information that is needed to run the machine: Code and Values. After we selected that, all indicators should turn green. It means that we are ready to start the machine. Now we want to click 'Run' button.

After a Turing program have executed, we can navigate on a tape with Left and Right button to read the result.

\section{Further research on Turing Machines}
\subsection{Turing set}
\textbf{\large E}ach Turing machine is defined by its code. By selecting different input values we obtain some output. There are two cases either this result is a tape with finite number of 1 and 0; or machine could never stop. Either way we have an infinite set $\{(input,\ output), \forall\ input\}$. Although, this set equally defines a Turing machine, this set is not finite. We can't store this set in computer memory.

\begin{definition}
The set $\mathbi{T}\subset\bigcup\limits_{k=1}^{\infty}\mathbb{N}^k$ is called a \textbf{Turing set} if there exists a Turing program whose output set equals to $\mathbi{T}$.
\end{definition}

We can represent an infinite set of vectors with some finite \emph{Turing code}. This set has to be a \emph{Turing set}.

\subsection{Acquire a Turing code}
\textbf{\large G}iven some Turing machine $M$. Its code is unknown to us. But we can still use the machine. 

Let $\mathbi{I}\subset\bigcup\limits_{k=1}^{\infty}\mathbb{N}^k$ be an \emph{input} set.

Based on some set of results $\{(input,\ output):\  \forall\ input\in \mathbi{I}\}$ we might draw some assumptions on what the machine actually does. We can definitely build a machine $\hat{M}$. Can we guarantee that machine $M$ will be identical to its emulation $\hat{M}$? Another question is: will $M$ and $\hat{M}$ have the same result on $\bigcup\limits_{k=1}^{\infty}\mathbb{N}^k$?

Before formulating a hypothesis, we need a definition.

\begin{definition}
Turing machine is called \textbf{irreducible} if we can not obtain another Turing machine which has the same input-output set but with shorter Turing code. 
\end{definition}

\textsc{Hypothesis}: If $M$ and $\hat{M}$ are \emph{irreducible}, their Turing code have the same length $n$, and they produce the same result on $\{1,\ \dots\ ,\ 2^n\}\subset\mathbb{N}$. Then $M$ is equivalent to $\hat{M}$.

\subsection{Possible Application in Artificial Intelligence}
\textbf{\large I}remember playing in the game. We had 4 teams and 2-4 members in each team. The rules were: each team has to write a coherent story, using words that were given one per minute (those words were completely unrelated). The winner is a team with the most interesting story. It also should make sense.

My team had 2 players. It was just me and a girl. We were trying our best to relate those words in our story. Somewhere at the end of the game, the word 'temple' came up. It didn't fit in our fairy-tale at all. I began to build the most feasible version of further developing of our story. And I proposed it.

Obviously, the way I made the word fit in a story sounded quirky. My teammate didn't like it, so she started to think about continuation aloud. She exactly repeated my chain of thoughts, and \emph{arrived to the same result} as I did. We ended up having the same continuation of our story, despite we thought independently

It may be just a coincidence or we think in similar way. To the extent when we tend to align our story to the new word in the same way. It may demonstrate that we had the same comprehension of the game rules and it may be a sign that we have similar mindset. Now, what does that have to do with AI?

If only we can make some robot to comprehend rules and enrich its mindset with ideas and experience, we can expect him to make identical conclusions that a human would do.

With that being said, lets consider some Turing machine with unknown code. We can draw an analogy between \emph{original code} of a Turing machine and \emph{mindset} of a human. Our task is to obtain a code. Once it is done, we are able to run this code in order to predict what Turing machine would do.

As it was mentioned in \textsf{Acquire a Turing code
} section, we may build at least some approximation of a Turing machine based on its input-output data.

\vspace{5mm}
\begin{addmargin}[3em]{3em}
\tab
\textsc{Facebook Likes Analogy.} There is a person that sometimes hits on a like button under some posts. Wouldn't that be nice to supply posts that the person is more likely to 'like'?

In order to do that we need to create a somewhat accurate virtual representation of that particular person. And than test all posts on their 'likeability' on the model, before supplying it to a real person. If an accurate model likes a post, chances are a person would like it.

We can build a model of a real person by analyzing input-output data. In that case the data is presented in this way: $$\{(post,\ like):\ post\in Posts,\ like\in\{Yes,\ No\}\}.$$

It is necessary to describe a post in some terms. We want to distinguish them from each other, likewise to point out similarities between them.

After that is done, we would like to convert this data set in Turing input-output set. Based on that set, we will create a Turing code, in the way it was explained in Turing set \textsf{Acquire a Turing code
} section.

This will be a Turing model of our facebook user. 
\end{addmargin}

\begin{remark}
Even though an emulation of a our behavior with Turing machines doesn't appear like an accurate representation of humans with all our enormous complexity, I still believe it is a good start.
\end{remark}

% \newfontfamily{\A}{Geeza Pro}
% \newfontfamily{\H}[Scale=0.9]{Lucida Grande}
% \newfontfamily{\J}[Scale=0.85]{Osaka}

% Here are some multilingual Unicode fonts: this is Arabic text: {\A السلام عليكم}, this is Hebrew: {\H שלום}, 
% and here's some Japanese: {\J 今日は}.


\end{document}  
